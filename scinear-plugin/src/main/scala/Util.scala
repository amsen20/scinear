package scinear

import dotty.tools.dotc.ast.tpd
import dotty.tools.dotc.core.Contexts.Context
import dotty.tools.dotc.core.Symbols
import dotty.tools.dotc.core.TypeUtils
import dotty.tools.dotc.core.Types

// Generated variable e.g.: $1$
final val GENERATED_VAR_PATTERN = "(\\$\\d+\\$)".r
// Generated field access methods e.g.: _1
final val FIELD_ACCESS_PATTERN = "(_\\d+)".r
// Generated default copy methods e.g.: copy$default$1
final val COPY_DEFAULT_PATTERN = "(copy\\$default\\$\\d+)".r
// Generated copy method
final val COPY_PATTERN = "(copy)".r

/** TODO: use definitions from `dotty.tools.dotc.core.Definitions` in the context to find the
  * variables generated by the compiler
  */
def isCompilerGeneratedVariable(sym: Symbols.Symbol)(using Context): Boolean = {
  val name = sym.name.toString
  GENERATED_VAR_PATTERN.matches(name)
}

def isFieldAccessorMethod(methodName: String)(using Context): Boolean = {
  FIELD_ACCESS_PATTERN.matches(methodName)
}

/** TODO: use definitions from `dotty.tools.dotc.core.Definitions` in the context to find the
  * methods generated by the compiler
  */
def isCompilerGeneratedMethod(defDef: tpd.DefDef)(using Context): Boolean = {
  val name = defDef.name.toString

  if (FIELD_ACCESS_PATTERN.matches(name)) return true
  if (COPY_DEFAULT_PATTERN.matches(name)) return true
  if (COPY_PATTERN.matches(name)) return true
  false
}

def isFunctionOkToHaveUnsafeAccess(fun: tpd.Tree)(using Context): Boolean = {
  fun match
    case tpd.Select(_, name) =>
      name.toString == "apply" || name.toString == "unapply" || name.toString == "<init>"
    case _ => false
}

def flattenOrTypes(tpe: Types.Type): List[Types.Type] = tpe match
  case Types.OrType(left, right) =>
    flattenOrTypes(left) ++ flattenOrTypes(right)
  case _ => List(tpe)
